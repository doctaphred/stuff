#!/usr/bin/env bash
set -euo pipefail

test -v STUFF || STUFF="$(dirname "$(dirname "$(realpath "$0")")")"

log () {
    # Echo to stderr.
    >&2 echo "$@"
}

key () {
    # Derive the key for the data at stdin.
    #
    # shasum reads from stdin by default.
    # The first 64 characters of the output is the SHA-256 hash.
    shasum -a256 | cut -c-64
}

verify () {
    verify-key "$(define "$1")"
}

verify-key () {
    # Exit 1 if the data at stdin does not match the expected key.
    expected="$1"
    actual="$(key)"
    test "$actual" = "$expected"
}

save () {
    # Save the data from stdin and echo its key.
    tempfile="$(mktemp -t stuff)"
    # Write stdin to the temp file, and also derive the key.
    key="$(tee "$tempfile" | key)"
    mkdir -p "$STUFF/data"
    # Now that we know the key, we can just move the temp file.
    mv "$tempfile" "$STUFF/data/$key"
    echo "$key"
}

save-as () {
    # Save the data from stdin, and give it a name.
    name="$1"
    key="$(save)"
    name "$key" "$name"
}

learn () {
    # Learn a URL for a key.
    #
    # TODO: multiple at once?
    # TODO: forget?
    key="$1"
    url="$2"
    mkdir -p "$STUFF/urls"
    echo "$url" >>"$STUFF/urls/$key"

    mkdir -p "$STUFF/responses/$url"
    echo "$key" >"$STUFF/responses/$url/$(date -u +%FT%T)"
}

locate () {
    locate-key "$(define "$1")"
}

locate-key () {
    # List known URLs for the given key.
    #
    # TODO: multiple at once?
    key="$1"
    if test -e "$STUFF/urls/$key"; then
        cat "$STUFF/urls/$key"
    else
        log "No known URLs for $key"
    fi
}

download () {
    # Download data from the URL, and save both for future use.
    #
    # TODO: multiple at once?
    url="$1"
    key="$(curl -L "$url" | save)"
    # Save the URL for future use.
    learn "$key" "$url"
    echo "$key"
}

download-all () {
    xargs -n1 -P32 stuff download
    # while read url; do download "$url"; done
    # key="$(curl "$url" | save)"
    # # Save the URL for future use.
    # learn "$key" "$url"
    # echo "$key"
}

download-as () {
    name="$1"
    url="$2"
    key="$(download "$2")"
    name "$key" "$name"
    echo "$key"
}

update () {
    name="$1"
    key="$(define "$name")"
    locate "$name" | while read url; do
        key="$(download "$url")" || continue
        name "$key" "$name"
        break
    done
    echo "$key"
}

get () {
    # Retrieve the data with the given name.
    #
    # TODO: multiple at once?
    name="$1"
    key="$(define "$name")"
    log "Retrieving $key"
    retrieve "$key"
}

retrieve () {
    # Retrieve the data with the given key, either from cache or a URL.
    #
    # TODO: multiple at once?
    key="$1"
    if test -e "$STUFF/data/$key"; then
        # Verify the integrity of the data we have.
        verify-key "$key" <"$STUFF/data/$key"
    else
        log "No local data for $key"
        locate-key "$key" | while read url; do
            # The data doesn't exist, but a URLs file does.
            log "Downloading from $url"
            actual="$(download "$url")" || continue
            if test "$actual" = "$key"; then
                log "Successfully downloaded $key"
                break
            else
                log "Received unexpected data: $actual"
            fi
        done

        if ! test -e "$STUFF/data/$key"; then
            log "ERROR: could not retrieve $key"
            exit 1
        fi
    fi
    cat "$STUFF/data/$key"
}

name () {
    # Assign an arbitrary name to a key.
    key="$1"
    name="$2"
    mkdir -p "$STUFF/names"
    echo "$key" >"$STUFF/names/$name"
}

alias () {
    name="$1"
    alias="$2"
    key="$(define "$name")"
    name "$key" "$alias"
}

unname () {
    name="$1"
    if test -e "$STUFF/names/$name"; then
        cat "$STUFF/names/$name"
        rm "$STUFF/names/$name"
    else
        log "Nothing is named '$name'"
        exit 1
    fi
}

define () {
    # Get the key with the given name.
    #
    # TODO: multiple at once?
    name="$1"
    if test -e "$STUFF/names/$name"; then
        cat "$STUFF/names/$name"
    else
        log "Nothing is named '$name'"
        exit 1
    fi
}

clear () {
    clear-key "$(define "$1")"
}

clear-key () {
    # Remove the key' data from cache.
    #
    # TODO: multiple at once?
    key="$1"
    rm "$STUFF/data/$key"
}

purge () {
    purge-key "$(define "$1")"
}

purge-key () {
    # Remove the key's data, and any known URLs.
    #
    # TODO: multiple at once?
    key="$1"
    rm "$STUFF/data/$key" 2>/dev/null || true
    rm "$STUFF/urls/$key" 2>/dev/null || true
    # TODO: remove from names?
}

ls () {
    # List all names.
    env ls -1 "$STUFF/names"
}

ls-keys () {
    # List all cached keys.
    env ls -1 "$STUFF/data"
}

clean () {
    key="$1"
    # <"$STUFF/data/$key" verify-key "$key" || clear-key "$key"
    if ! verify-key "$key" <"$STUFF/data/$key"; then
        clear-key "$key"
        log "Deleted corrupted data $key"
    fi
}

sanitize () {
    # Clear any corrupted data from the cache.
    ls-keys | xargs -n1 -P "$(nproc)" stuff clean
    # ls-keys | while read key; do
    #     if ! verify-key "$key" <"$STUFF/data/$key"; then
    #         clear-key "$key"
    #         log "Deleted corrupted data $key"
    #     fi
    # done
}

"$@"
