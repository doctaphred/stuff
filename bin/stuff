#!/usr/bin/env bash
set -euo pipefail

test -v STUFF || STUFF="$(dirname "$(dirname "$(realpath "$0")")")"

log () {
    # Echo to stderr.
    >&2 echo "$@"
}

key () {
    # Derive the key for the data at stdin.
    #
    # shasum reads from stdin by default.
    # The first 64 characters of the output is the SHA-256 hash.
    shasum -a256 | cut -c-64
}

verify () {
    # Exit 1 if the data at stdin does not match the expected key.
    #
    expected="$1"
    actual="$(key)"
    test "$actual" = "$expected"
}

store () {
    # Store the data from stdin under the appropriate key.
    #
    tempfile="$(mktemp -t stuff)"
    # Write stdin to the temp file, and also derive the key.
    key="$(tee "$tempfile" | key)"
    mkdir -p "$STUFF/data"
    # Now that we know the key, we can just move the temp file.
    mv "$tempfile" "$STUFF/data/$key"
    echo "$key"
}

learn () {
    # Learn a URL for a key.
    #
    # TODO: multiple at once?
    # TODO: forget?
    key="$1"
    url="$2"
    mkdir -p "$STUFF/urls"
    echo "$url" >>"$STUFF/urls/$key"
}

locate () {
    # List known URLs for the given key.
    #
    # TODO: multiple at once?
    key="$1"
    if test -e "$STUFF/urls/$key"; then
        cat "$STUFF/urls/$key"
    else
        log "No known URLs for $key"
    fi
}

download () {
    # Download, store, and learn a URL.
    #
    # TODO: multiple at once?
    url="$1"
    key="$(curl "$url" | store)"
    # Save the URL for future use.
    learn "$key" "$url"
    echo "$key"
}

get () {
    # Retrieve the given key, either from cache or a URL.
    #
    # TODO: multiple at once?
    key="$1"
    if test -e "$STUFF/data/$key"; then
        # Verify the integrity of the data we have.
        verify "$key" <"$STUFF/data/$key"
    else
        log "Data not found"
        if test -e "$STUFF/urls/$key"; then
            # The data doesn't exist, but a URLs file does.
            # Count the lines in the URLs file, and remove the
            # obnoxious leading whitespace from the result.
            n="$(wc -l <"$STUFF/urls/$key" | tr -d ' ')"
            log "Attempting to download from $n URL(s)"
            while read url; do
                log "Downloading from $url"
                actual="$(download "$url" || continue)"
                if test "$actual" = "$key"; then
                    log "Successfully downloaded $key"
                    break
                else
                    log "Downloaded unexpected data: $actual"
                fi
            done < "$STUFF/urls/$key"
            if ! test -e "$STUFF/data/$key"; then
                log "ERROR: could not download $key"
                exit 1
            fi
        else
            log "ERROR: no data or URLs defined for $key"
            exit 1
        fi
    fi
    cat "$STUFF/data/$key"
}

call () {
    # Assign an arbitrary name to a key.
    #
    # TODO: un-name?
    key="$1"
    name="$2"
    mkdir -p "$STUFF/names"
    echo "$key" >"$STUFF/names/$name"
}

define () {
    # Get the key with the given name.
    #
    # TODO: multiple at once?
    name="$1"
    if test -e "$STUFF/names/$name"; then
        cat "$STUFF/names/$name"
    else
        log "Nothing is named '$name'"
        exit 1
    fi
}

lookup () {
    # Get the data with the given name.
    #
    # TODO: multiple at once?
    name="$1"
    key="$(define "$name")"
    get "$key"
}

clear () {
    # Remove the key' data from cache.
    #
    # TODO: multiple at once?
    key="$1"
    rm "$STUFF/data/$key"
}

purge () {
    # Remove the key's data, and any known URLs.
    #
    # TODO: multiple at once?
    key="$1"
    rm "$STUFF/data/$key" 2>/dev/null || true
    rm "$STUFF/urls/$key" 2>/dev/null || true
    # TODO: remove from names?
}

list () {
    # List all cached keys.
    #
    # TODO: List URLs too? Separately?
    ls "$STUFF/data"
}

names () {
    # List all names.
    #
    ls "$STUFF/names"
}

sanitize () {
    # Clear any corrupted data from the cache.
    #
    list | while read key; do
        if ! verify "$key" <"$STUFF/data/$key"; then
            clear "$key"
            log "Deleted corrupted data $key"
        fi
    done
}

"$@"
